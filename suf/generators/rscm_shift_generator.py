#!/usr/bin/env python
"""
RSCM shift generator.

Generates structurally identical RSCM-style datapaths while permuting the bit
ordering. The permutation changes the wiring burden (and therefore physical
cost) without changing logical operators or counts of mux2 / HA / FA cells.
"""
from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, Iterable, List, Sequence

from jinja2 import Template

from suf import FLOW_ROOT

# Jinja template for a single RTL variant. The logic footprint is constant; only
# the permutation of `a` bits changes the wiring.
_VERILOG_TEMPLATE = Template(
    r"""
// Autogenerated by RSCMShiftGenerator
module {{ module_name }} #(
  parameter integer N = {{ n }},
  parameter integer K = {{ k }}
)(
  input  wire                  clk,
  input  wire                  sel,
  input  wire [N-1:0]          a,
  input  wire [N-1:0]          b,
  output wire [N:0]            sum
);

  // Permute the A operand. This is the only thing that varies across variants.
  wire [N-1:0] permuted_a;
{% for idx, src in permutation %}
  assign permuted_a[{{ idx }}] = a[{{ src }}];
{% endfor %}

  wire [N-1:0] mux_out;
  genvar i;
  generate
    for (i = 0; i < N; i = i + 1) begin : gen_mux
      mux2 u_mux (.a0(permuted_a[i]), .a1(b[i]), .sel(sel), .y(mux_out[i]));
    end
  endgenerate

  // Pairwise pre-reduction to keep HA/FA counts constant.
  localparam integer HA_COUNT = N/2;
  wire [N-1:0] csa_sum;
  wire [N-1:0] csa_carry;
  generate
    for (i = 0; i < N; i = i + 1) begin : gen_csa
      if (i < HA_COUNT) begin
        ha u_ha (.a(mux_out[2*i]), .b(mux_out[2*i+1]), .sum(csa_sum[i]), .carry(csa_carry[i]));
      end else begin
        assign csa_sum[i]   = mux_out[i];
        assign csa_carry[i] = 1'b0;
      end
    end
  endgenerate

  // Balanced ripple accumulation
  wire [N:0] carry_chain;
  assign carry_chain[0] = 1'b0;
  generate
    for (i = 0; i < N; i = i + 1) begin : gen_fa
      fa u_fa (.a(csa_sum[i]), .b(csa_carry[i]), .cin(carry_chain[i]), .sum(sum[i]), .cout(carry_chain[i+1]));
    end
  endgenerate
  assign sum[N] = carry_chain[N];
endmodule

// Library of constant-complexity primitives
module mux2(input wire a0, input wire a1, input wire sel, output wire y);
  assign y = sel ? a1 : a0;
endmodule

module ha(input wire a, input wire b, output wire sum, output wire carry);
  assign sum   = a ^ b;
  assign carry = a & b;
endmodule

module fa(input wire a, input wire b, input wire cin, output wire sum, output wire cout);
  assign {cout, sum} = a + b + cin;
endmodule
"""
)


@dataclass
class DisplacementMetrics:
    linear: int
    quadratic: int


@dataclass
class RSCMVariant:
    name: str
    permutation: List[int]
    rtl_path: Path
    metrics: DisplacementMetrics
    metadata: Dict[str, object] = field(default_factory=dict)


class RSCMShiftGenerator:
    """Generate permuted RSCM datapaths."""

    def __init__(
        self,
        output_root: Path | None = None,
        flow_root: Path | None = None,
        module_basename: str = "rscm_shift",
        n: int = 32,
        k: int = 4,
    ) -> None:
        self.flow_root = flow_root if flow_root is not None else FLOW_ROOT
        self.output_root = output_root or (
            self.flow_root / "designs" / "src" / module_basename
        )
        self.module_basename = module_basename
        self.n = n
        self.k = k
        self.output_root.mkdir(parents=True, exist_ok=True)

    def compute_displacement(self, permutation: Sequence[int]) -> DisplacementMetrics:
        """Compute Σ|π(i)-i| and Σ|π(i)-i|² for a permutation."""
        if len(permutation) != self.n:
            raise ValueError(f"Permutation length {len(permutation)} != N={self.n}")
        linear = sum(abs(dst - src) for dst, src in enumerate(permutation))
        quadratic = sum((abs(dst - src)) ** 2 for dst, src in enumerate(permutation))
        return DisplacementMetrics(linear=linear, quadratic=quadratic)

    def _render_verilog(self, name: str, permutation: Sequence[int]) -> str:
        """Render a single RTL variant."""
        entries = list(enumerate(permutation))
        return _VERILOG_TEMPLATE.render(
            module_name=name,
            n=self.n,
            k=self.k,
            permutation=entries,
        )

    def generate_variants(
        self, permutations: Iterable[Sequence[int]], prefix: str | None = None
    ) -> List[RSCMVariant]:
        """
        Create RTL variants for a collection of permutations.

        Args:
            permutations: Iterable of index permutations.
            prefix: Optional prefix for design names.

        Returns:
            List of RSCMVariant instances describing generated RTL.
        """
        variants: List[RSCMVariant] = []
        for idx, permutation in enumerate(permutations):
            name = prefix or self.module_basename
            design_name = f"{name}_{idx:03d}"
            metrics = self.compute_displacement(permutation)
            verilog = self._render_verilog(design_name, permutation)
            design_dir = self.output_root / design_name
            design_dir.mkdir(parents=True, exist_ok=True)
            rtl_path = design_dir / f"{design_name}.v"
            rtl_path.write_text(verilog)
            variants.append(
                RSCMVariant(
                    name=design_name,
                    permutation=list(permutation),
                    rtl_path=rtl_path,
                    metrics=metrics,
                    metadata={
                        "L": metrics.linear,
                        "Q": metrics.quadratic,
                        "n": self.n,
                        "k": self.k,
                    },
                )
            )
        return variants
